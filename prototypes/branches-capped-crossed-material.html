<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Acid</title>
  <link rel="shortcut icon" href="#">
  <style>
    body {
      margin: 0;
    }
  </style>
  <script type="module">
    import * as THREE from '../js/three.module.js';
    import { TrackballControls } from '../js/TrackballControls.js';
    import * as Axis from '../js/shapes/axis.js';

    let camera, scene, renderer, controls;
    let coronalTubeTop, coronalTubeBottom, saggitalTubeFront, saggitalTubeBack;
    let coronalTopRight, coronalTopLeft, coronalTopBack, coronalTopFront;
    let coronalBottomRight, coronalBottomLeft, coronalBottomBack, coronalBottomFront;
    let saggitalBackTop, saggitalBackBottom, saggitalBackLeft, saggitalBackRight;
    let saggitalFrontTop, saggitalFrontBottom, saggitalFrontLeft, saggitalFrontRight;
    let unit;
    let unitLength = 8;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 3500);
      camera.position.x = 44;
      camera.position.y = 35;
      camera.position.z = 115;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);
      controls = new TrackballControls(camera, renderer.domElement);

      window.addEventListener('resize', onWindowResize);

      unit = new THREE.Group();

      const tubeMaterial = new THREE.MeshPhongMaterial({
        //color: 0xFC3EC1,
        color: 0xffffff,
        shininess: 150,
        side: THREE.DoubleSide,
        //emissive: 'red'
      });

      function degreesToRadians(degrees) {
        var pi = Math.PI;
        return degrees * (Math.PI / 180);
      }

      // Add Segment

      function addSegment(name, start, direction, magnitude) {
        const coordinates = [];
        coordinates.push(new THREE.Vector3(start[0], start[1], start[2]));
        const end = returnEndPosition(start, direction, magnitude);
        coordinates.push(new THREE.Vector3(end[0], end[1], end[2]));
        const curve = new THREE.CatmullRomCurve3(coordinates);
        const geometry = new THREE.TubeGeometry(curve, 64, .05, 16, false)
        globalThis[name] = new THREE.Mesh(geometry, tubeMaterial);
        unit.add(globalThis[name]);
      }

      // Find End Coordinates for New Segment

      function returnEndPosition(startPosition, direction, magnitude) {
        const startX = startPosition[0];
        const startY = startPosition[1];
        const startZ = startPosition[2];
        const dirX = direction[0];
        const dirY = direction[1];
        const dirZ = direction[2];
        let endPosition = [];
        endPosition.push(dirX * magnitude + startX);
        endPosition.push(dirY * magnitude + startY);
        endPosition.push(dirZ * magnitude + startZ);
        console.log(endPosition);
        return endPosition;
      }

      const vectorMap = {
        coronal:  {
          center: [0, Math.cos(degreesToRadians(0)),0],
          front: [0, Math.cos(degreesToRadians(45)),Math.cos(degreesToRadians(45))],
          back: [0, Math.cos(degreesToRadians(45)),Math.cos(degreesToRadians(135))],
          left: [Math.cos(degreesToRadians(45)),Math.cos(degreesToRadians(45)),0],
          right: [Math.cos(degreesToRadians(135)),Math.cos(degreesToRadians(45)),0]
        },
        transverse:  {
          center: [Math.cos(degreesToRadians(0)),0,0],
          front: [Math.cos(degreesToRadians(45)),0,Math.cos(degreesToRadians(45))],
          back: [Math.cos(degreesToRadians(45)),0,Math.cos(degreesToRadians(135))],
          left: [Math.cos(degreesToRadians(45)),Math.cos(degreesToRadians(135)), 0], // bottom
          right: [Math.cos(degreesToRadians(45)),Math.cos(degreesToRadians(45)),0] // top
        },
        saggital:  {
          center: [0,0,Math.cos(degreesToRadians(0))],
          front: [Math.cos(degreesToRadians(45)),0,Math.cos(degreesToRadians(45))],
          back: [Math.cos(degreesToRadians(135)),0,Math.cos(degreesToRadians(45))],
          left: [0,Math.cos(degreesToRadians(135)),Math.cos(degreesToRadians(45))], // bottom
          right: [0,Math.cos(degreesToRadians(45)),Math.cos(degreesToRadians(45))] // top
        }
      }

      function addLevel(start, plane, orientation, magnitude, branches) {
        if (orientation === 'negative') {
          magnitude = magnitude * -1;
        }
        if (branches === 1) {
          addSegment(plane+orientation+'center', start, vectorMap[plane].center, magnitude/Math.sqrt(2));
        }
        if (branches === 5) {
          addSegment(plane+orientation+'center', start,vectorMap[plane].center, magnitude/Math.sqrt(2));
          addSegment(plane+orientation+'front', start, vectorMap[plane].front, magnitude);
          addSegment(plane+orientation+'back', start, vectorMap[plane].back, magnitude);
          addSegment(plane+orientation+'left', start, vectorMap[plane].left, magnitude);
          addSegment(plane+orientation+'right', start, vectorMap[plane].right, magnitude);
        }
      }

      // Coronal 
        // Top
      addLevel([0, 0, 0], 'coronal', 'positive', unitLength * Math.sqrt(2),1);
      addLevel([0, unitLength, 0], 'coronal', 'positive', unitLength * Math.sqrt(2),5);
          // Cap
      addLevel([0, 3*unitLength, 0], 'coronal', 'negative', unitLength * Math.sqrt(2),5);
        // Bottom
      addLevel([0, 0, 0], 'coronal','negative', unitLength * Math.sqrt(2),1);
      addLevel([0, -unitLength, 0],'coronal','negative', unitLength * Math.sqrt(2),5);
          // Cap
      addLevel([0, 3*-unitLength, 0],'coronal','positive', unitLength * Math.sqrt(2),5);
         // Origin Spread
        
           // Top
      addSegment('coronalOriginSpreadFront',[0,unitLength*2,0],[0,0,1],unitLength)
      addSegment('coronalOriginSpreadBack',[0,unitLength*2,0],[0,0,-1],unitLength)
      addSegment('coronalOriginSpreadLeft',[0,unitLength*2,0],[1,0,0],unitLength)
      addSegment('coronalOriginSpreadRight',[0,unitLength*2,0],[-1,0,0],unitLength)

      const colors = [
        0, 0, 1,
        1, 0, 1,
        0, 1, 1,

        1, 0, 1,
        0, 1, 1,
        0, 0, 1,

        0, 1, 1,
        0, 0, 1,
        1, 0, 1,
      ]

      const material = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        vertexColors: true,
        transparent: true,
        opacity: .50 
      });


      // Coronal Top

      const geometryPane = new THREE.BufferGeometry();
      geometryPane.setAttribute('position', new THREE.Float32BufferAttribute([0,24,0, 0,16,8, 8,16,0], 3));
      geometryPane.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane = new THREE.Mesh(geometryPane, material);
      scene.add(meshPane);

      const geometryPane0 = new THREE.BufferGeometry();
      geometryPane0.setAttribute('position', new THREE.Float32BufferAttribute([0,24,0, 0,16,8, -8,16,0], 3));
      geometryPane0.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane0 = new THREE.Mesh(geometryPane0, material);
      scene.add(meshPane0);

      const geometryPane1 = new THREE.BufferGeometry();
      geometryPane1.setAttribute('position', new THREE.Float32BufferAttribute([0,24,0, 0,16,-8, -8,16,0], 3));
      geometryPane1.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane1 = new THREE.Mesh(geometryPane1, material);
      scene.add(meshPane1);

      const geometryPane2 = new THREE.BufferGeometry();
      geometryPane2.setAttribute('position', new THREE.Float32BufferAttribute([0,24,0, 0,16,-8, 8,16,0], 3));
      geometryPane2.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane2 = new THREE.Mesh(geometryPane2, material);
      scene.add(meshPane2);


      const geometryPane3 = new THREE.BufferGeometry();
      geometryPane3.setAttribute('position', new THREE.Float32BufferAttribute([0,8,0, 0,16,8, 8,16,0], 3));
      geometryPane3.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane3 = new THREE.Mesh(geometryPane3, material);
      scene.add(meshPane3);

      const geometryPane4 = new THREE.BufferGeometry();
      geometryPane4.setAttribute('position', new THREE.Float32BufferAttribute([0,8,0, 0,16,8, -8,16,0], 3));
      geometryPane4.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane4 = new THREE.Mesh(geometryPane4, material);
      scene.add(meshPane4);

      const geometryPane5 = new THREE.BufferGeometry();
      geometryPane5.setAttribute('position', new THREE.Float32BufferAttribute([0,8,0, 0,16,-8, -8,16,0], 3));
      geometryPane5.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane5 = new THREE.Mesh(geometryPane5, material);
      scene.add(meshPane5);

      const geometryPane6 = new THREE.BufferGeometry();
      geometryPane6.setAttribute('position', new THREE.Float32BufferAttribute([0,8,0, 0,16,-8, 8,16,0], 3));
      geometryPane6.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane6 = new THREE.Mesh(geometryPane6, material);
      scene.add(meshPane6);


      // Coronal Bottom

      const geometryPane7 = new THREE.BufferGeometry();
      geometryPane7.setAttribute('position', new THREE.Float32BufferAttribute([0,-24,0, 0,-16,8, 8,-16,0], 3));
      geometryPane7.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane7 = new THREE.Mesh(geometryPane7, material);
      scene.add(meshPane7);

      const geometryPane8 = new THREE.BufferGeometry();
      geometryPane8.setAttribute('position', new THREE.Float32BufferAttribute([0,-24,0, 0,-16,8, -8,-16,0], 3));
      geometryPane8.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane8 = new THREE.Mesh(geometryPane8, material);
      scene.add(meshPane8);

      const geometryPane9 = new THREE.BufferGeometry();
      geometryPane9.setAttribute('position', new THREE.Float32BufferAttribute([0,-24,0, 0,-16,-8, -8,-16,0], 3));
      geometryPane9.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane9 = new THREE.Mesh(geometryPane9, material);
      scene.add(meshPane9);

      const geometryPane10 = new THREE.BufferGeometry();
      geometryPane10.setAttribute('position', new THREE.Float32BufferAttribute([0,-24,0, 0,-16,-8, 8,-16,0], 3));
      geometryPane10.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane10 = new THREE.Mesh(geometryPane10, material);
      scene.add(meshPane10);

      const geometryPane11 = new THREE.BufferGeometry();
      geometryPane11.setAttribute('position', new THREE.Float32BufferAttribute([0,-8,0, 0,-16,8, 8,-16,0], 3));
      geometryPane11.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane11 = new THREE.Mesh(geometryPane11, material);
      scene.add(meshPane11);

      const geometryPane12 = new THREE.BufferGeometry();
      geometryPane12.setAttribute('position', new THREE.Float32BufferAttribute([0,-8,0, 0,-16,8, -8,-16,0], 3));
      geometryPane12.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane12 = new THREE.Mesh(geometryPane12, material);
      scene.add(meshPane12);

      const geometryPane13 = new THREE.BufferGeometry();
      geometryPane13.setAttribute('position', new THREE.Float32BufferAttribute([0,-8,0, 0,-16,-8, -8,-16,0], 3));
      geometryPane13.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane13 = new THREE.Mesh(geometryPane13, material);
      scene.add(meshPane13);

      const geometryPane14 = new THREE.BufferGeometry();
      geometryPane14.setAttribute('position', new THREE.Float32BufferAttribute([0,-8,0, 0,-16,-8, 8,-16,0], 3));
      geometryPane14.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane14 = new THREE.Mesh(geometryPane14, material);
      scene.add(meshPane14);

      
           // Bottom
      addSegment('coronalOriginSpreadFront',[0,-unitLength*2,0],[0,0,1],unitLength)
      addSegment('coronalOriginSpreadBack',[0,-unitLength*2,0],[0,0,-1],unitLength)
      addSegment('coronalOriginSpreadLeft',[0,-unitLength*2,0],[1,0,0],unitLength)
      addSegment('coronalOriginSpreadRight',[0,-unitLength*2,0],[-1,0,0],unitLength)

      


      // Transverse
        // Left
      addLevel([0, 0, 0], 'transverse', 'positive', unitLength * Math.sqrt(2),1);
      addLevel([unitLength, 0, 0], 'transverse', 'positive', unitLength * Math.sqrt(2),5);
          // Cap
      addLevel([3*unitLength, 0, 0], 'transverse', 'negative', unitLength * Math.sqrt(2),5);
        // Right
      addLevel([0, 0, 0], 'transverse', 'negative', unitLength * Math.sqrt(2),1);
      addLevel([-unitLength, 0, 0], 'transverse', 'negative', unitLength * Math.sqrt(2),5);
          // Cap
      addLevel([3*-unitLength, 0, 0], 'transverse', 'positive', unitLength * Math.sqrt(2),5);
      // Origin Spread
           // Left
      addSegment('coronalOriginSpreadFront',[unitLength*2,0,0],[0,1,0],unitLength)
      addSegment('coronalOriginSpreadBack',[unitLength*2,0,0],[0,-1,0],unitLength)
      addSegment('coronalOriginSpreadLeft',[unitLength*2,0,0],[0,0,1],unitLength)
      addSegment('coronalOriginSpreadRight',[unitLength*2,0,0],[0,0,-1],unitLength)
           // Right
      addSegment('coronalOriginSpreadFront',[-unitLength*2,0,0],[0,1,0],unitLength)
      addSegment('coronalOriginSpreadBack',[-unitLength*2,0,0],[0,-1,0],unitLength)
      addSegment('coronalOriginSpreadLeft',[-unitLength*2,0,0],[0,0,1],unitLength)
      addSegment('coronalOriginSpreadRight',[-unitLength*2,0,0],[0,0,-1],unitLength)

      // Transverse

      // Right

      const geometryPane15 = new THREE.BufferGeometry();
      geometryPane15.setAttribute('position', new THREE.Float32BufferAttribute([-24,0,0, -16,8,0, -16,0,8], 3));
      geometryPane15.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane15 = new THREE.Mesh(geometryPane15, material);
      scene.add(meshPane15);

      const geometryPane16 = new THREE.BufferGeometry();
      geometryPane16.setAttribute('position', new THREE.Float32BufferAttribute([-24,0,0, -16,8,0, -16,0,-8], 3));
      geometryPane16.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane16 = new THREE.Mesh(geometryPane16, material);
      scene.add(meshPane16);

      const geometryPane17 = new THREE.BufferGeometry();
      geometryPane17.setAttribute('position', new THREE.Float32BufferAttribute([-8,0,0, -16,8,0, -16,0,-8], 3));
      geometryPane17.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane17 = new THREE.Mesh(geometryPane17, material);
      scene.add(meshPane17);

      const geometryPane18 = new THREE.BufferGeometry();
      geometryPane18.setAttribute('position', new THREE.Float32BufferAttribute([-8,0,0, -16,8,0, -16,0,8], 3));
      geometryPane18.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane18 = new THREE.Mesh(geometryPane18, material);
      scene.add(meshPane18);


      const geometryPane19 = new THREE.BufferGeometry();
      geometryPane19.setAttribute('position', new THREE.Float32BufferAttribute([-24,0,0, -16,-8,0, -16,0,8], 3));
      geometryPane19.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane19 = new THREE.Mesh(geometryPane19, material);
      scene.add(meshPane19);

      const geometryPane20 = new THREE.BufferGeometry();
      geometryPane20.setAttribute('position', new THREE.Float32BufferAttribute([-24,0,0, -16,-8,0, -16,0,-8], 3));
      geometryPane20.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane20 = new THREE.Mesh(geometryPane20, material);
      scene.add(meshPane20);

      const geometryPane21 = new THREE.BufferGeometry();
      geometryPane21.setAttribute('position', new THREE.Float32BufferAttribute([-8,0,0, -16,-8,0, -16,0,-8], 3));
      geometryPane21.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane21 = new THREE.Mesh(geometryPane21, material);
      scene.add(meshPane21);

      const geometryPane22 = new THREE.BufferGeometry();
      geometryPane22.setAttribute('position', new THREE.Float32BufferAttribute([-8,0,0, -16,-8,0, -16,0,8], 3));
      geometryPane22.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane22 = new THREE.Mesh(geometryPane22, material);
      scene.add(meshPane22);

      // Left

      const geometryPane23 = new THREE.BufferGeometry();
      geometryPane23.setAttribute('position', new THREE.Float32BufferAttribute([24,0,0, 16,8,0, 16,0,8], 3));
      geometryPane23.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane23 = new THREE.Mesh(geometryPane23, material);
      scene.add(meshPane23);

      const geometryPane24 = new THREE.BufferGeometry();
      geometryPane24.setAttribute('position', new THREE.Float32BufferAttribute([24,0,0, 16,8,0, 16,0,-8], 3));
      geometryPane24.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane24 = new THREE.Mesh(geometryPane24, material);
      scene.add(meshPane24);

      const geometryPane25 = new THREE.BufferGeometry();
      geometryPane25.setAttribute('position', new THREE.Float32BufferAttribute([8,0,0, 16,8,0, 16,0,-8], 3));
      geometryPane25.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane25 = new THREE.Mesh(geometryPane25, material);
      scene.add(meshPane25);


      const geometryPane26 = new THREE.BufferGeometry();
      geometryPane26.setAttribute('position', new THREE.Float32BufferAttribute([8,0,0, 16,8,0, 16,0,8], 3));
      geometryPane26.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane26 = new THREE.Mesh(geometryPane26, material);
      scene.add(meshPane26);

      /*c


      const geometryPane19 = new THREE.BufferGeometry();
      geometryPane19.setAttribute('position', new THREE.Float32BufferAttribute([-24,0,0, -16,-8,0, -16,0,8], 3));
      geometryPane19.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane19 = new THREE.Mesh(geometryPane19, material);
      scene.add(meshPane19);

      const geometryPane20 = new THREE.BufferGeometry();
      geometryPane20.setAttribute('position', new THREE.Float32BufferAttribute([-24,0,0, -16,-8,0, -16,0,-8], 3));
      geometryPane20.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane20 = new THREE.Mesh(geometryPane20, material);
      scene.add(meshPane20);

      const geometryPane21 = new THREE.BufferGeometry();
      geometryPane21.setAttribute('position', new THREE.Float32BufferAttribute([-8,0,0, -16,-8,0, -16,0,-8], 3));
      geometryPane21.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane21 = new THREE.Mesh(geometryPane21, material);
      scene.add(meshPane21);

      const geometryPane22 = new THREE.BufferGeometry();
      geometryPane22.setAttribute('position', new THREE.Float32BufferAttribute([-8,0,0, -16,-8,0, -16,0,8], 3));
      geometryPane22.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const meshPane22 = new THREE.Mesh(geometryPane22, material);
      scene.add(meshPane22);*/

      /*
      // Saggital
       // Front
      addLevel([0, 0, 0], 'saggital', 'positive', unitLength * Math.sqrt(2),1);
      addLevel([0, 0, unitLength], 'saggital', 'positive', unitLength * Math.sqrt(2),5);
          // Cap
      addLevel([0, 0, 3*unitLength], 'saggital', 'negative', unitLength * Math.sqrt(2),5);
       // Back
      addLevel([0, 0, 0], 'saggital', 'negative', unitLength * Math.sqrt(2),1);
      addLevel([0, 0, -unitLength], 'saggital', 'negative', unitLength * Math.sqrt(2),5);
          // Cap
      addLevel([0, 0, 3*-unitLength], 'saggital', 'positive', unitLength * Math.sqrt(2),5);

      // Origin Spread
           // Front
      addSegment('coronalOriginSpreadLeft',[0,0,unitLength*2],[1,0,0],unitLength)
      addSegment('coronalOriginSpreadRight',[0,0,unitLength*2],[-1,0,0],unitLength)
      addSegment('coronalOriginSpreadFront',[0,0,unitLength*2],[0,1,0],unitLength)
      addSegment('coronalOriginSpreadBack',[0,0,unitLength*2],[0,-1,0],unitLength)
           // Back
      addSegment('coronalOriginSpreadFront',[0,0,-unitLength*2],[1,0,0],unitLength)
      addSegment('coronalOriginSpreadBack',[0,0,-unitLength*2],[-1,0,0],unitLength)
      addSegment('coronalOriginSpreadLeft',[0,0,-unitLength*2],[0,1,0],unitLength)
      addSegment('coronalOriginSpreadRight',[0,0,-unitLength*2],[0,-1,0],unitLength)
      */


      scene.add(unit);

      /*const axesHelper = new THREE.AxesHelper( 50 );
      scene.add( axesHelper );*/

      scene.background = new THREE.Color(0x161616);

      /*const light = new THREE.DirectionalLight(0xfffffff, 1);
      light.position.set(1, 1, 1)//.normalize();
      scene.add(light);*/

      const lightColorHash = 0x888888;

      const light1 = new THREE.DirectionalLight(lightColorHash, 1);
      light1.position.set(-1, -1, -1)//.normalize();
      scene.add(light1);

      const light2 = new THREE.DirectionalLight(lightColorHash, 1);
      light2.position.set(1, 1, 1)//.normalize();
      scene.add(light2);


      const lightAmbient = new THREE.AmbientLight(lightColorHash,.75 ); // soft white light
      scene.add( lightAmbient );
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();
      //stats.update();
    }

      //unit.rotation.x -= 0.20;
      //unit.rotation.y += 0.80;
      //unit.rotation.z += 0.50;

    function render() {

      const time = Date.now() * 0.002;

      /*unit.rotation.x = time * 0.15;
      unit.rotation.y = time * 0.20;
      unit.rotation.z = time * 0.15;*/

      //unit.rotation.y += .0075;

      renderer.render(scene, camera);
    }

  </script>
</head>

<body>
</body>

</html>