<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Acid</title>
  <link rel="shortcut icon" href="#">
  <style>
    body {
      margin: 0;
    }
  </style>
  <script type="module">
    import * as THREE from '../js/three.module.js';
    import { TrackballControls } from '../js/TrackballControls.js';
    import * as Axis from '../js/shapes/axis.js';
    import { unit, tubeMaterial, returnEndPosition, addVectorLine, addLine, degreesToRadians } from '../js/utilities.js'

    let camera, scene, renderer, controls;
    let mesh0, mesh1, mesh2, mesh3, mesh4, mesh5, mesh6, mesh7;
    let coronalTubeTop, coronalTubeBottom, saggitalTubeFront, saggitalTubeBack;
    let coronalTopRight, coronalTopLeft, coronalTopBack, coronalTopFront;
    let coronalBottomRight, coronalBottomLeft, coronalBottomBack, coronalBottomFront;
    let saggitalBackTop, saggitalBackBottom, saggitalBackLeft, saggitalBackRight;
    let saggitalFrontTop, saggitalFrontBottom, saggitalFrontLeft, saggitalFrontRight;
    let unitLength = 8;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(37, window.innerWidth / window.innerHeight, 1, 3500);
      camera.position.x = 30;
      camera.position.y = 0;
      camera.position.z = 250;
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      controls = new TrackballControls(camera, renderer.domElement);
      window.addEventListener('resize', onWindowResize);

      // Acid Crystal 

      class AcidCrystal {

        constructor(name,type,origin,unitLength) {

          console.log('name',name);
          console.log('origin',origin);
          const [orgX, orgY, orgZ] = origin;

          // Segment - Center
          addLine(
            [
              orgX,
              orgY+unitLength,
              orgZ
            ],
            [
              orgX,
              orgY-unitLength,
              orgZ
            ]
          );

          // Segment X+ 
          // Base
          addLine(
            [
              orgX+unitLength,
              orgY+unitLength,
              orgZ
            ],
            [
              orgX+unitLength,
              orgY-unitLength,
              orgZ
            ]
          );
          // Y Pos
          addVectorLine('X_Pos_Y_Pos',[orgX+unitLength,orgY+unitLength,orgZ],
          [
            Math.cos(degreesToRadians(0)),
            Math.cos(degreesToRadians(45)),
            Math.cos(degreesToRadians(90))
          ],
            unitLength*Math.sqrt(3)
          );
          // Y Bisect
          addLine(
            [
              orgX+unitLength,
              orgY,
              orgZ
            ],
            [ orgX+(unitLength)+unitLength*Math.sqrt(3),
              orgY,
              orgZ
            ]);
          // Y Neg
          addVectorLine('X_Pos_Y_Neg',[orgX+unitLength,orgY-unitLength,orgZ],
          [
            Math.cos(degreesToRadians(0)),
            Math.cos(degreesToRadians(135)),
            Math.cos(degreesToRadians(90))
          ],
            unitLength*Math.sqrt(3));

            // XZ Pos 

            // Base
            addLine(
              [
               orgX+unitLength/2,
               orgY+unitLength,
               orgZ+(unitLength*Math.sqrt(3))/2
              ],
              [
                orgX+unitLength/2,
                orgY-unitLength,
                orgZ+(unitLength*Math.sqrt(3))/2
              ]
            );

            // XZ Pos

             // Y Pos
            addVectorLine('XZ_Pos_Y_Pos',[orgX+(unitLength/2),orgY+unitLength,orgZ+(unitLength*Math.sqrt(3))/2],
            [
            Math.cos(degreesToRadians(60)),
            Math.cos(degreesToRadians(45)),
            Math.cos(degreesToRadians(30))],
            unitLength*Math.sqrt(3));

            // Y Neg
            addVectorLine('XZ_Pos_Y_Neg',[orgX+(unitLength/2),orgY-unitLength,orgZ+(unitLength*Math.sqrt(3))/2],
            [
            Math.cos(degreesToRadians(60)),
            Math.cos(degreesToRadians(135)),
            Math.cos(degreesToRadians(30))],
            unitLength*Math.sqrt(3));

            // Y Bisect
            addVectorLine('XZ_Pos_Y_Bisect',[orgX+(unitLength/2),orgY,orgZ+(unitLength*Math.sqrt(3))/2],
            [
            Math.cos(degreesToRadians(60)),
            Math.cos(degreesToRadians(90)),
            Math.cos(degreesToRadians(30))],
            unitLength*Math.sqrt(3));

            // X Neg

            // Base
            addLine(
              [
              orgX-unitLength,
              orgY+unitLength,
              orgZ
            ],
            [
              orgX-unitLength,
              orgY-unitLength,
              orgZ
            ]);

            // Y Pos
            addVectorLine('X_Neg_Y_Pos',[orgX-unitLength,orgY+unitLength,orgZ],
            [
              Math.cos(degreesToRadians(180)),
              Math.cos(degreesToRadians(45)),
              Math.cos(degreesToRadians(90))
            ],
              unitLength*Math.sqrt(3)
            );

            // Y Neg
            addVectorLine('X_Neg_Y_Neg',[orgX-unitLength,orgY-unitLength,orgZ],
            [
              Math.cos(degreesToRadians(180)),
              Math.cos(degreesToRadians(135)),
              Math.cos(degreesToRadians(90))
            ],
             unitLength*Math.sqrt(3)
            );
    
            // Y Bisect
            addLine([orgX-unitLength,orgY,orgZ],[orgX-unitLength-unitLength*Math.sqrt(3),orgY,orgZ]);

            // XZ Neg 

            // Base
            addLine(
              [
                orgX-(unitLength/2),
                orgY+unitLength,
                orgZ-(unitLength*Math.sqrt(3))/2
              ],
              [
                orgX-(unitLength/2),
                orgY-unitLength,
                orgZ-(unitLength*Math.sqrt(3))/2
              ]
            );

            // Y Pos
            addVectorLine('XZ_Neg_Y_Pos',[orgX-(unitLength/2),orgY+unitLength,orgZ-(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(240)),
            Math.cos(degreesToRadians(45)),
            Math.cos(degreesToRadians(210))],
            unitLength*Math.sqrt(3));

            // Y Neg
            addVectorLine('XZ_Neg_Y_Neg',[orgX-(unitLength/2),orgY-unitLength,orgZ-(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(240)),
            Math.cos(degreesToRadians(135)),
            Math.cos(degreesToRadians(215))],
            unitLength*Math.sqrt(3));

            // Y Bisect
            addVectorLine('XZ_Neg_Y_Bisect',[orgX-(unitLength/2),orgY,orgZ-(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(240)),
            Math.cos(degreesToRadians(90)),
            Math.cos(degreesToRadians(210))],
            unitLength*Math.sqrt(3));

            // X Neg Z Pos 

            // Base
            addLine([orgX-unitLength/2,orgY+unitLength,orgZ+(unitLength*Math.sqrt(3))/2],[orgX-(unitLength/2),orgY-unitLength,orgZ+(unitLength*Math.sqrt(3))/2]);

            // Y Pos
            addVectorLine('X_Neg_Z_Pos_Y_Pos',[orgX-(unitLength/2),orgY+unitLength,orgZ+(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(120)),
            Math.cos(degreesToRadians(45)),
            Math.cos(degreesToRadians(30))],
            unitLength*Math.sqrt(3));

            // Y Neg

            addVectorLine('X_Neg_Z_Pos_Y_Neg',[orgX-(unitLength/2),orgY-unitLength,orgZ+(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(120)),
            Math.cos(degreesToRadians(135)),
            Math.cos(degreesToRadians(30))],
            unitLength*Math.sqrt(3));

            // Y Bisect 
            addVectorLine('X_Pos_Z_Neg_Y_Bisect',[orgX-(unitLength/2),orgY,orgZ+(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(120)),
            Math.cos(degreesToRadians(90)),
            Math.cos(degreesToRadians(30))],
            unitLength*Math.sqrt(3));

            // X Pos Z Neg 

            // Base
            addLine([orgX+(unitLength/2),orgY+unitLength,orgZ-(unitLength*Math.sqrt(3))/2],[orgX+(unitLength/2),orgY-unitLength,orgZ-(unitLength*Math.sqrt(3))/2]);

            // Y Pos
            addVectorLine('X_Pos_Z_Neg_Y_Pos',[orgX+(unitLength/2),orgY+unitLength,orgZ-(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(300)),
            Math.cos(degreesToRadians(45)),
            Math.cos(degreesToRadians(210))],
            unitLength*Math.sqrt(3));

            // Y Bisect
            addVectorLine('X_Pos_Z_Neg_Y_Bisect',[orgX+(unitLength/2),orgY,orgZ-(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(300)),
            Math.cos(degreesToRadians(90)),
            Math.cos(degreesToRadians(210))],
            unitLength*Math.sqrt(3));

            // Y Neg
            addVectorLine('X_Pos_Z_Neg_Y_Neg',[orgX+(unitLength/2),orgY-unitLength,orgZ-(unitLength*Math.sqrt(3))/2],
            [Math.cos(degreesToRadians(300)),
            Math.cos(degreesToRadians(135)),
            Math.cos(degreesToRadians(210))],
            unitLength*Math.sqrt(3));

        }

      }

      const AC_Org = new AcidCrystal('center',6,[0,0,0],unitLength)

      /*const AC_X_Pos = new AcidCrystal('X_Pos',6,[(2*unitLength)+(2*unitLength*Math.sqrt(3)),0,0],unitLength);
      const AC_X_Neg = new AcidCrystal('X_Neg',6,[(-2*unitLength)+(-2*unitLength*Math.sqrt(3)),0,0],unitLength);*/

      /*const AC_Z_Neg = new AcidCrystal('Z_Neg',6,[0,0,(-2*unitLength)+(-2*unitLength*Math.sqrt(3))],unitLength);
      const AC_Z_Pos = new AcidCrystal('Z_Pos',6,[0,0,(2*unitLength)+(2*unitLength*Math.sqrt(3))],unitLength);*/

      /*const AC_Y_Pos = new AcidCrystal('Y_Pos',6,[0,4.5*unitLength,0],unitLength);
      const AC_Y_Neg = new AcidCrystal('Y_Neg',6,[0,-4.5*unitLength,0],unitLength);*/
      

      scene.add(unit);

      /*const axesHelper = new THREE.AxesHelper( 50 );
      scene.add( axesHelper );*/

      scene.background = new THREE.Color(0x111111);

      const light0 = new THREE.DirectionalLight(0xfffffff, 1);
      light0.position.set(100, 100, 100)//.normalize();
      scene.add(light0);

      const light2 = new THREE.DirectionalLight(0xfffffff, 1);
      light2.position.set(-100, -100, -100)//.normalize();
      scene.add(light2);

      const light3 = new THREE.DirectionalLight(0xfffffff, 1);
      light3.position.set(100, -100, 100)//.normalize();
      scene.add(light3);

      const light4 = new THREE.DirectionalLight(0xfffffff, 1);
      light4.position.set(-100, 100, -100)//.normalize();
      scene.add(light4);

    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();
      //stats.update();
    }

    //unit.rotation.z -= .3;
    //unit.rotation.y -= .3;
    //unit.rotation.x += .3;

    function render() {

      const time = Date.now() * 0.002;

      //unit.rotation.x = time * 0.2;
      //unit.rotation.y = time * -0.25;
      //unit.rotation.z = time * .03;

      renderer.render(scene, camera);
    }

  </script>
</head>

<body>
</body>

</html>