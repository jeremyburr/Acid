<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Acid</title>
  <link rel="shortcut icon" href="#">
  <style>
    body {
      margin: 0;
    }
  </style>
  <script type="module">
    import * as THREE from '../js/three.module.js';
    import { TrackballControls } from '../js/TrackballControls.js';
    import * as Axis from '../js/shapes/axis.js';

    let camera, scene, renderer, controls;
    let coronalTubeTop, coronalTubeBottom, saggitalTubeFront, saggitalTubeBack;
    let coronalTopRight, coronalTopLeft, coronalTopBack, coronalTopFront;
    let coronalBottomRight, coronalBottomLeft, coronalBottomBack, coronalBottomFront;
    let saggitalBackTop, saggitalBackBottom, saggitalBackLeft, saggitalBackRight;
    let saggitalFrontTop, saggitalFrontBottom, saggitalFrontLeft, saggitalFrontRight;
    let unit;
    let unitLength = 8;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 3500);
      camera.position.x = 44;
      camera.position.y = 55;
      camera.position.z = 115;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);
      controls = new TrackballControls(camera, renderer.domElement);

      window.addEventListener('resize', onWindowResize);

      unit = new THREE.Group();

      const tubeMaterial = new THREE.MeshPhongMaterial({
        //color: 0xFC3EC1,
        color: 0xffffff,
        shininess: 150,
        side: THREE.DoubleSide,
        //emissive: 'red'
      });

      function degreesToRadians(degrees) {
        var pi = Math.PI;
        return degrees * (Math.PI / 180);
      }

      const colors = [
        0, 0, 1,
        1, 0, 1,
        0, 1, 1,
      ]

      const material = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        vertexColors: true,
        transparent: true,
        opacity: .9
      });

      const materialLight = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        vertexColors: true,
        transparent: true,
        opacity: .9 
      });
      
      const wingColors = [
        1, .46, 0,
        1, 0, 0,
        1, 1, 0,
      ]

      const crystalColors = [
        0, .94, .2,
        .45, 1, .95,
        .1, .2, .98,
      ]

      // Crystals

      // Octant Four

      // Green Teal Blue

      const fourUpFront = new THREE.BufferGeometry();
      fourUpFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,4*Math.sqrt(2),8, 8,4*Math.sqrt(2),0], 3));
      fourUpFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourUpFront = new THREE.Mesh(fourUpFront, materialLight);
      unit.add(meshfourUpFront);

      const fourTopLeft = new THREE.BufferGeometry();
      fourTopLeft.setAttribute('position', new THREE.Float32BufferAttribute([8,4*Math.sqrt(2),16,0,4*Math.sqrt(2),8,8,4*Math.sqrt(2),0, ], 3));
      fourTopLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourTopLeft = new THREE.Mesh(fourTopLeft, materialLight);
      unit.add(meshfourTopLeft);

      const fourTopRight = new THREE.BufferGeometry();
      fourTopRight.setAttribute('position', new THREE.Float32BufferAttribute([8,4*Math.sqrt(2),16, 16,4*Math.sqrt(2),8, 8,4*Math.sqrt(2),0, ], 3));
      fourTopRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourTopRight = new THREE.Mesh(fourTopRight, materialLight);
      unit.add(meshfourTopRight);

      const fourTopBack = new THREE.BufferGeometry();
      fourTopBack.setAttribute('position', new THREE.Float32BufferAttribute([8,4*Math.sqrt(2),16, 16,4*Math.sqrt(2),8,16,0,16], 3));
      fourTopBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourTopBack = new THREE.Mesh(fourTopBack, materialLight);
      unit.add(meshfourTopBack);

      const fourDownFront = new THREE.BufferGeometry();
      fourDownFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,-4*Math.sqrt(2),8, 8,-4*Math.sqrt(2),0], 3));
      fourDownFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownFront = new THREE.Mesh(fourDownFront, materialLight);
      unit.add(meshfourDownFront);
      
      const fourDownLeft = new THREE.BufferGeometry();
      fourDownLeft.setAttribute('position', new THREE.Float32BufferAttribute([8,-4*Math.sqrt(2),16, 0,-4*Math.sqrt(2),8, 8,-4*Math.sqrt(2),0, ], 3));
      fourDownLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownLeft = new THREE.Mesh(fourDownLeft, materialLight);
      unit.add(meshfourDownLeft);

      const fourDownRight = new THREE.BufferGeometry();
      fourDownRight.setAttribute('position', new THREE.Float32BufferAttribute([8,-4*Math.sqrt(2),16, 16,-4*Math.sqrt(2),8, 8,-4*Math.sqrt(2),0, ], 3));
      fourDownRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownRight = new THREE.Mesh(fourDownRight, materialLight);
      unit.add(meshfourDownRight);
      
      const fourDownBack = new THREE.BufferGeometry();
      fourDownBack.setAttribute('position', new THREE.Float32BufferAttribute([8,-4*Math.sqrt(2),16, 16,-4*Math.sqrt(2),8, 16,0,16], 3));
      fourDownBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownBack = new THREE.Mesh(fourDownBack, materialLight);
      unit.add(meshfourDownBack);

      // Green Teal Blue

      const fourLeftFront = new THREE.BufferGeometry();
      fourLeftFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,4*Math.sqrt(2),8, 0,-4*Math.sqrt(2),8], 3));
      fourLeftFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourLeftFront = new THREE.Mesh(fourLeftFront, materialLight);
      unit.add(meshfourLeftFront);

      const fourLeftTop = new THREE.BufferGeometry();
      fourLeftTop.setAttribute('position', new THREE.Float32BufferAttribute([8,4*Math.sqrt(2),16, 0,4*Math.sqrt(2),8, 0,-4*Math.sqrt(2),8, ], 3));
      fourLeftTop.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourLeftTop = new THREE.Mesh(fourLeftTop, materialLight);
      unit.add(meshfourLeftTop);

      const fourLeftBottom = new THREE.BufferGeometry();
      fourLeftBottom.setAttribute('position', new THREE.Float32BufferAttribute([8,4*Math.sqrt(2),16, 8,-4*Math.sqrt(2),16,  0,-4*Math.sqrt(2),8, ], 3));
      fourLeftBottom.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourLeftBottom = new THREE.Mesh(fourLeftBottom, materialLight);
      unit.add(meshfourLeftBottom);

      const fourLeftBack = new THREE.BufferGeometry();
      fourLeftBack.setAttribute('position', new THREE.Float32BufferAttribute([8,4*Math.sqrt(2),16, 8,-4*Math.sqrt(2),16,  16,0,16, ], 3));
      fourLeftBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourLeftBack = new THREE.Mesh(fourLeftBack, materialLight);
      unit.add(meshfourLeftBack);

      // Right

      const fourRightFront = new THREE.BufferGeometry();
      fourRightFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,8,4*Math.sqrt(2),0, 8,-4*Math.sqrt(2),0], 3));
      fourRightFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourRightFront = new THREE.Mesh(fourRightFront, materialLight);
      unit.add(meshfourRightFront);

      const fourRightTop = new THREE.BufferGeometry();
      fourRightTop.setAttribute('position', new THREE.Float32BufferAttribute([16,4*Math.sqrt(2),8 ,8,4*Math.sqrt(2),0, 8,-4*Math.sqrt(2),0], 3));
      fourRightTop.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourRightTop = new THREE.Mesh(fourRightTop, materialLight);
      unit.add(meshfourRightTop);

      const fourRightBottom = new THREE.BufferGeometry();
      fourRightBottom.setAttribute('position', new THREE.Float32BufferAttribute([16,4*Math.sqrt(2),8 ,16,-4*Math.sqrt(2),8, 8,-4*Math.sqrt(2),0], 3));
      fourRightBottom.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourRightBottom = new THREE.Mesh(fourRightBottom, materialLight);
      unit.add(meshfourRightBottom);

      const fourRightBack = new THREE.BufferGeometry();
      fourRightBack.setAttribute('position', new THREE.Float32BufferAttribute([16,4*Math.sqrt(2),8, 16,-4*Math.sqrt(2),8,  16,0,16, ], 3));
      fourRightBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourRightBack = new THREE.Mesh(fourRightBack, materialLight);
      unit.add(meshfourRightBack);


      
      /*const fourDownRight = new THREE.BufferGeometry();
      fourDownLeft.setAttribute('position', new THREE.Float32BufferAttribute([8,-4,16, 0,-4,8, 8,-4,0, ], 3));
      fourDownLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownLeft = new THREE.Mesh(fourDownLeft, materialLight);
      unit.add(meshfourDownLeft);

      const fourDownRight = new THREE.BufferGeometry();
      fourDownRight.setAttribute('position', new THREE.Float32BufferAttribute([8,-4,16, 16,-4,8, 8,-4,0, ], 3));
      fourDownRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownRight = new THREE.Mesh(fourDownRight, materialLight);
      unit.add(meshfourDownRight);
      
      const fourDownBack = new THREE.BufferGeometry();
      fourDownBack.setAttribute('position', new THREE.Float32BufferAttribute([8,-4,16, 16,-4,8, 16,0,16], 3));
      fourDownBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshfourDownBack = new THREE.Mesh(fourDownBack, materialLight);
      unit.add(meshfourDownBack);*/







      scene.add(unit);

      /*const axesHelper = new THREE.AxesHelper( 50 );
      scene.add( axesHelper );*/

      scene.background = new THREE.Color(0x000000);


      const lightColorHash = 0xFFFFFF;

      const light1 = new THREE.DirectionalLight(lightColorHash, 1);
      light1.position.set(-1, -1, -1)//.normalize();
      scene.add(light1);

      const light2 = new THREE.DirectionalLight(lightColorHash, 1);
      light2.position.set(1, 1, 1)//.normalize();
      scene.add(light2);


      const lightAmbient = new THREE.AmbientLight(lightColorHash,1 ); // soft white light
      scene.add( lightAmbient );
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();
      //stats.update();
    }

      //unit.rotation.x -= 0.20;
      //unit.rotation.y += 0.90;
      //unit.rotation.z += 0.50;

    function render() {

      const time = Date.now() * 0.002;

      //unit.rotation.x = time * 0.15;
      //unit.rotation.y = time * -0.25;
      //unit.rotation.z = time * 0.15;


      renderer.render(scene, camera);
    }

  </script>
</head>

<body>
</body>

</html>