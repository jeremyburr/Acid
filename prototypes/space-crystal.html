<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Acid</title>
  <link rel="shortcut icon" href="#">
  <style>
    body {
      margin: 0;
    }
  </style>
  <script type="module">
    import * as THREE from '../js/three.module.js';
    import { TrackballControls } from '../js/TrackballControls.js';
    import * as Axis from '../js/shapes/axis.js';

    let camera, scene, renderer, controls;
    let coronalTubeTop, coronalTubeBottom, saggitalTubeFront, saggitalTubeBack;
    let coronalTopRight, coronalTopLeft, coronalTopBack, coronalTopFront;
    let coronalBottomRight, coronalBottomLeft, coronalBottomBack, coronalBottomFront;
    let saggitalBackTop, saggitalBackBottom, saggitalBackLeft, saggitalBackRight;
    let saggitalFrontTop, saggitalFrontBottom, saggitalFrontLeft, saggitalFrontRight;
    let unit;
    let unitLength = 8;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 3500);
      camera.position.x = 44;
      camera.position.y = 55;
      camera.position.z = 115;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);
      controls = new TrackballControls(camera, renderer.domElement);

      window.addEventListener('resize', onWindowResize);

      unit = new THREE.Group();

      const tubeMaterial = new THREE.MeshPhongMaterial({
        //color: 0xFC3EC1,
        color: 0xffffff,
        shininess: 150,
        side: THREE.DoubleSide,
        //emissive: 'red'
      });

      function degreesToRadians(degrees) {
        var pi = Math.PI;
        return degrees * (Math.PI / 180);
      }

      const colors = [
        0, 0, 1,
        1, 0, 1,
        0, 1, 1,
      ]

      const material = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        vertexColors: true,
        transparent: true,
        opacity: .9
      });

      const materialLight = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        vertexColors: true,
        transparent: true,
        opacity: .9 
      });
      
      const wingColors = [
        1, .46, 0,
        1, 0, 0,
        1, 1, 0,
      ]

      const crystalColors = [
        0, .94, .2,
        .45, 1, .95,
        .1, .2, .98,
      ]

      const val = 4*Math.sqrt(2);


      // Crystals

      // Octant One

      // Green Teal Blue

      const oneUpFront = new THREE.BufferGeometry();
      oneUpFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,val,-8, -8,val,0], 3));
      oneUpFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneUpFront = new THREE.Mesh(oneUpFront, materialLight);
      unit.add(meshoneUpFront);

      const oneTopLeft = new THREE.BufferGeometry();
      oneTopLeft.setAttribute('position', new THREE.Float32BufferAttribute([-8,val,-16, 0,val,-8, -8,val,0, ], 3));
      oneTopLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneTopLeft = new THREE.Mesh(oneTopLeft, materialLight);
      unit.add(meshoneTopLeft);

      const oneTopRight = new THREE.BufferGeometry();
      oneTopRight.setAttribute('position', new THREE.Float32BufferAttribute([-8,val,-16, -16,val,-8, -8,val,0, ], 3));
      oneTopRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneTopRight = new THREE.Mesh(oneTopRight, materialLight);
      unit.add(meshoneTopRight);

      const oneTopBack = new THREE.BufferGeometry();
      oneTopBack.setAttribute('position', new THREE.Float32BufferAttribute([-8,val,-16, -16,val,-8, -16,0,-16], 3));
      oneTopBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneTopBack = new THREE.Mesh(oneTopBack, materialLight);
      unit.add(meshoneTopBack);

      const oneDownFront = new THREE.BufferGeometry();
      oneDownFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,-val,-8, -8,-val,0], 3));
      oneDownFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneDownFront = new THREE.Mesh(oneDownFront, materialLight);
      unit.add(meshoneDownFront);
      
      const oneDownLeft = new THREE.BufferGeometry();
      oneDownLeft.setAttribute('position', new THREE.Float32BufferAttribute([-8,-val,-16, 0,-val,-8, -8,-val,0, ], 3));
      oneDownLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneDownLeft = new THREE.Mesh(oneDownLeft, materialLight);
      unit.add(meshoneDownLeft);

      const oneDownRight = new THREE.BufferGeometry();
      oneDownRight.setAttribute('position', new THREE.Float32BufferAttribute([-8,-val,-16, -16,-val,-8, -8,-val,0, ], 3));
      oneDownRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneDownRight = new THREE.Mesh(oneDownRight, materialLight);
      unit.add(meshoneDownRight);
      
      const oneDownBack = new THREE.BufferGeometry();
      oneDownBack.setAttribute('position', new THREE.Float32BufferAttribute([-8,-val,-16, -16,-val,-8, -16,0,-16], 3));
      oneDownBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneDownBack = new THREE.Mesh(oneDownBack, materialLight);
      unit.add(meshoneDownBack);

      // Green Teal Blue

      const oneLeftFront = new THREE.BufferGeometry();
      oneLeftFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,val,-8, 0,-val,-8], 3));
      oneLeftFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneLeftFront = new THREE.Mesh(oneLeftFront, materialLight);
      unit.add(meshoneLeftFront);

      const oneLeftTop = new THREE.BufferGeometry();
      oneLeftTop.setAttribute('position', new THREE.Float32BufferAttribute([-8,val,-16, 0,val,-8, 0,-val,-8, ], 3));
      oneLeftTop.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneLeftTop = new THREE.Mesh(oneLeftTop, materialLight);
      unit.add(meshoneLeftTop);

      const oneLeftBottom = new THREE.BufferGeometry();
      oneLeftBottom.setAttribute('position', new THREE.Float32BufferAttribute([-8,val,-16, -8,-val,-16,  0,-val,-8, ], 3));
      oneLeftBottom.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneLeftBottom = new THREE.Mesh(oneLeftBottom, materialLight);
      unit.add(meshoneLeftBottom);

      const oneLeftBack = new THREE.BufferGeometry();
      oneLeftBack.setAttribute('position', new THREE.Float32BufferAttribute([-8,val,-16, -8,-val,-16,  -16,0,-16, ], 3));
      oneLeftBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneLeftBack = new THREE.Mesh(oneLeftBack, materialLight);
      unit.add(meshoneLeftBack);

      // Right

      const oneRightFront = new THREE.BufferGeometry();
      oneRightFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,-8,val,0, -8,-val,0], 3));
      oneRightFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneRightFront = new THREE.Mesh(oneRightFront, materialLight);
      unit.add(meshoneRightFront);

      const oneRightTop = new THREE.BufferGeometry();
      oneRightTop.setAttribute('position', new THREE.Float32BufferAttribute([-16,val,-8, -8,val,0, -8,-val,0], 3));
      oneRightTop.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneRightTop = new THREE.Mesh(oneRightTop, materialLight);
      unit.add(meshoneRightTop);

      const oneRightBottom = new THREE.BufferGeometry();
      oneRightBottom.setAttribute('position', new THREE.Float32BufferAttribute([-16,val,-8, -16,-val,-8, -8,-val,0], 3));
      oneRightBottom.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneRightBottom = new THREE.Mesh(oneRightBottom, materialLight);
      unit.add(meshoneRightBottom);

      const oneRightBack = new THREE.BufferGeometry();
      oneRightBack.setAttribute('position', new THREE.Float32BufferAttribute([-16,val,-8, -16,-val,-8,  -16,0,-16, ], 3));
      oneRightBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshoneRightBack = new THREE.Mesh(oneRightBack, materialLight);
      unit.add(meshoneRightBack);



    // Octant Seven

      // Green Teal Blue

      const sevenUpFront = new THREE.BufferGeometry();
      sevenUpFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,val,8, 8,val,0], 3));
      sevenUpFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenUpFront = new THREE.Mesh(sevenUpFront, materialLight);
      unit.add(meshsevenUpFront);

      const sevenTopLeft = new THREE.BufferGeometry();
      sevenTopLeft.setAttribute('position', new THREE.Float32BufferAttribute([8,val,16,0,val,8,8,val,0, ], 3));
      sevenTopLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenTopLeft = new THREE.Mesh(sevenTopLeft, materialLight);
      unit.add(meshsevenTopLeft);

      const sevenTopRight = new THREE.BufferGeometry();
      sevenTopRight.setAttribute('position', new THREE.Float32BufferAttribute([8,val,16, 16,val,8, 8,val,0, ], 3));
      sevenTopRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenTopRight = new THREE.Mesh(sevenTopRight, materialLight);
      unit.add(meshsevenTopRight);

      const sevenTopBack = new THREE.BufferGeometry();
      sevenTopBack.setAttribute('position', new THREE.Float32BufferAttribute([8,val,16, 16,val,8,16,0,16], 3));
      sevenTopBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenTopBack = new THREE.Mesh(sevenTopBack, materialLight);
      unit.add(meshsevenTopBack);

      const sevenDownFront = new THREE.BufferGeometry();
      sevenDownFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,-val,8, 8,-val,0], 3));
      sevenDownFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenDownFront = new THREE.Mesh(sevenDownFront, materialLight);
      unit.add(meshsevenDownFront);
      
      const sevenDownLeft = new THREE.BufferGeometry();
      sevenDownLeft.setAttribute('position', new THREE.Float32BufferAttribute([8,-val,16, 0,-val,8, 8,-val,0, ], 3));
      sevenDownLeft.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenDownLeft = new THREE.Mesh(sevenDownLeft, materialLight);
      unit.add(meshsevenDownLeft);

      const sevenDownRight = new THREE.BufferGeometry();
      sevenDownRight.setAttribute('position', new THREE.Float32BufferAttribute([8,-val,16, 16,-val,8, 8,-val,0, ], 3));
      sevenDownRight.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenDownRight = new THREE.Mesh(sevenDownRight, materialLight);
      unit.add(meshsevenDownRight);
      
      const sevenDownBack = new THREE.BufferGeometry();
      sevenDownBack.setAttribute('position', new THREE.Float32BufferAttribute([8,-val,16, 16,-val,8, 16,0,16], 3));
      sevenDownBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenDownBack = new THREE.Mesh(sevenDownBack, materialLight);
      unit.add(meshsevenDownBack);

      // Green Teal Blue

      const sevenLeftFront = new THREE.BufferGeometry();
      sevenLeftFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,0,val,8, 0,-val,8], 3));
      sevenLeftFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenLeftFront = new THREE.Mesh(sevenLeftFront, materialLight);
      unit.add(meshsevenLeftFront);

      const sevenLeftTop = new THREE.BufferGeometry();
      sevenLeftTop.setAttribute('position', new THREE.Float32BufferAttribute([8,val,16, 0,val,8, 0,-val,8, ], 3));
      sevenLeftTop.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenLeftTop = new THREE.Mesh(sevenLeftTop, materialLight);
      unit.add(meshsevenLeftTop);

      const sevenLeftBottom = new THREE.BufferGeometry();
      sevenLeftBottom.setAttribute('position', new THREE.Float32BufferAttribute([8,val,16, 8,-val,16,  0,-val,8, ], 3));
      sevenLeftBottom.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenLeftBottom = new THREE.Mesh(sevenLeftBottom, materialLight);
      unit.add(meshsevenLeftBottom);

      const sevenLeftBack = new THREE.BufferGeometry();
      sevenLeftBack.setAttribute('position', new THREE.Float32BufferAttribute([8,val,16, 8,-val,16,  16,0,16, ], 3));
      sevenLeftBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenLeftBack = new THREE.Mesh(sevenLeftBack, materialLight);
      unit.add(meshsevenLeftBack);

      // Right

      const sevenRightFront = new THREE.BufferGeometry();
      sevenRightFront.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0 ,8,val,0, 8,-val,0], 3));
      sevenRightFront.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenRightFront = new THREE.Mesh(sevenRightFront, materialLight);
      unit.add(meshsevenRightFront);

      const sevenRightTop = new THREE.BufferGeometry();
      sevenRightTop.setAttribute('position', new THREE.Float32BufferAttribute([16,val,8 ,8,val,0, 8,-val,0], 3));
      sevenRightTop.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenRightTop = new THREE.Mesh(sevenRightTop, materialLight);
      unit.add(meshsevenRightTop);

      const sevenRightBottom = new THREE.BufferGeometry();
      sevenRightBottom.setAttribute('position', new THREE.Float32BufferAttribute([16,val,8 ,16,-val,8, 8,-val,0], 3));
      sevenRightBottom.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenRightBottom = new THREE.Mesh(sevenRightBottom, materialLight);
      unit.add(meshsevenRightBottom);

      const sevenRightBack = new THREE.BufferGeometry();
      sevenRightBack.setAttribute('position', new THREE.Float32BufferAttribute([16,val,8, 16,-val,8,  16,0,16, ], 3));
      sevenRightBack.setAttribute('color', new THREE.Float32BufferAttribute(crystalColors, 3));
      const meshsevenRightBack = new THREE.Mesh(sevenRightBack, materialLight);
      unit.add(meshsevenRightBack);




      scene.add(unit);

      /*const axesHelper = new THREE.AxesHelper( 50 );
      scene.add( axesHelper );*/

      scene.background = new THREE.Color(0x000000);


      const lightColorHash = 0xFFFFFF;

      const light1 = new THREE.DirectionalLight(lightColorHash, 1);
      light1.position.set(-1, -1, -1)//.normalize();
      scene.add(light1);

      const light2 = new THREE.DirectionalLight(lightColorHash, 1);
      light2.position.set(1, 1, 1)//.normalize();
      scene.add(light2);


      const lightAmbient = new THREE.AmbientLight(lightColorHash,1 ); // soft white light
      scene.add( lightAmbient );
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();
      //stats.update();
    }

      //unit.rotation.x -= 0.20;
      //unit.rotation.y += 0.90;
      //unit.rotation.z += 0.50;

    function render() {

      const time = Date.now() * 0.002;

      //unit.rotation.x = time * 0.15;
      //unit.rotation.y = time * -0.25;
      //unit.rotation.z = time * 0.15;


      renderer.render(scene, camera);
    }

  </script>
</head>

<body>
</body>

</html>