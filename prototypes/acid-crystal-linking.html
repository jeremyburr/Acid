<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Acid</title>
  <link rel="shortcut icon" href="#">
  <style>
    body {
      margin: 0;
    }
  </style>
  <script type="module">
    import * as THREE from '../js/three.module.js';
    import { TrackballControls } from '../js/TrackballControls.js';
    import * as Axis from '../js/shapes/axis.js';
    import { unit, tubeMaterial, returnEndPosition, addSegment, testSegment, degreesToRadians } from '../js/utilities.js'

    let camera, scene, renderer, controls;
    let mesh0, mesh1, mesh2, mesh3, mesh4, mesh5, mesh6, mesh7;
    let coronalTubeTop, coronalTubeBottom, saggitalTubeFront, saggitalTubeBack;
    let coronalTopRight, coronalTopLeft, coronalTopBack, coronalTopFront;
    let coronalBottomRight, coronalBottomLeft, coronalBottomBack, coronalBottomFront;
    let saggitalBackTop, saggitalBackBottom, saggitalBackLeft, saggitalBackRight;
    let saggitalFrontTop, saggitalFrontBottom, saggitalFrontLeft, saggitalFrontRight;
    let unitLength = 8;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(37, window.innerWidth / window.innerHeight, 1, 3500);
      camera.position.x = 30;
      camera.position.y = 0;
      camera.position.z = 150;
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      controls = new TrackballControls(camera, renderer.domElement);
      window.addEventListener('resize', onWindowResize);

      // Acid Crystal 

      class AcidCrystal {

        constructor(name,origin,unitLength) {
          console.log('name',name);
          console.log('origin',origin);
          const [orgX, orgY, orgZ] = origin;

          // Segment - Center
          testSegment(
            [
              orgX,
              orgY+unitLength,
              orgZ
            ],
            [
              orgX,
              orgY-unitLength,
              orgZ
            ]
          );

          // Segment X+ 
          // Base
          testSegment(
            [
              orgX+unitLength,
              orgY+unitLength,
              orgZ
            ],
            [
              orgX+unitLength,
              orgY-unitLength,
              orgZ
            ]
          );
          // Y Pos
          addSegment('X_Pos_Y_Pos',[unitLength,unitLength,orgZ],
          [
            Math.cos(degreesToRadians(0)),
            Math.cos(degreesToRadians(45)),
            Math.cos(degreesToRadians(90))
          ],
            unitLength*Math.sqrt(3)
          );
          // Y Bisect
          testSegment([unitLength,orgY,orgZ],[(unitLength)+unitLength*Math.sqrt(3),orgY,orgZ]);
        }

      }


      const AC_Origin = new AcidCrystal('center',[0,0,0],8)
      //const AC_X_Pos = new AcidCrystal('X_Pos',[40,0,40],8)
      

      

      // Y Neg
      addSegment('X_Pos_Y_Neg',[8,-8,0],
      [Math.cos(degreesToRadians(0)),
      Math.cos(degreesToRadians(135)),
      Math.cos(degreesToRadians(90))],
      8*Math.sqrt(3));
        

      // XZ Pos 

      // Base
      testSegment([4,8,(8*Math.sqrt(3))/2],[4,-8,(8*Math.sqrt(3))/2]);

      // Y Pos
      addSegment('XZ_Pos_Y_Pos',[4,8,(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(60)),
      Math.cos(degreesToRadians(45)),
      Math.cos(degreesToRadians(30))],
      8*Math.sqrt(3));

      // Y Neg
      addSegment('XZ_Pos_Y_Neg',[4,-8,(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(60)),
      Math.cos(degreesToRadians(135)),
      Math.cos(degreesToRadians(30))],
      8*Math.sqrt(3));
        
      // Y Bisect
      addSegment('XZ_Pos_Y_Bisect',[4,0,(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(60)),
      Math.cos(degreesToRadians(90)),
      Math.cos(degreesToRadians(30))],
      8*Math.sqrt(3));

      // X Neg
      
      // Base
      testSegment([-8,8,0],[-8,-8,0]);

      // Y Pos
      addSegment('X_Neg_Y_Pos',[-8,8,0],
      [Math.cos(degreesToRadians(180)),
      Math.cos(degreesToRadians(45)),
      Math.cos(degreesToRadians(90))],
      8*Math.sqrt(3));

      // Y Neg
      addSegment('X_Neg_Y_Neg',[-8,-8,0],
      [Math.cos(degreesToRadians(180)),
      Math.cos(degreesToRadians(135)),
      Math.cos(degreesToRadians(90))],
      8*Math.sqrt(3));
    
       // Y Bisect
      testSegment([-8,0,0],[(-8)-8*Math.sqrt(3),0,0]);
      
      
      // XZ Neg 

      // Base
      testSegment([-4,8,-(8*Math.sqrt(3))/2],[-4,-8,-(8*Math.sqrt(3))/2]);

      // Y Pos
      addSegment('XZ_Neg_Y_Pos',[-4,8,-(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(240)),
      Math.cos(degreesToRadians(45)),
      Math.cos(degreesToRadians(210))],
      8*Math.sqrt(3));
      
      // Y Neg
      addSegment('XZ_Neg_Y_Neg',[-4,-8,-(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(240)),
      Math.cos(degreesToRadians(135)),
      Math.cos(degreesToRadians(215))],
      8*Math.sqrt(3));

      // Y Bisect
      addSegment('XZ_Neg_Y_Bisect',[-4,0,(-8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(240)),
      Math.cos(degreesToRadians(90)),
      Math.cos(degreesToRadians(210))],
      8*Math.sqrt(3));

      // X Neg Z Pos 

      // Bisect
      testSegment([-4,8,(8*Math.sqrt(3))/2],[-4,-8,(8*Math.sqrt(3))/2]);

      // Y Pos
      addSegment('X_Neg_Z_Pos_Y_Pos',[-4,8,(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(120)),
      Math.cos(degreesToRadians(45)),
      Math.cos(degreesToRadians(30))],
      8*Math.sqrt(3));
      
      // Y Neg
      addSegment('X_Neg_Z_Pos_Y_Neg',[-4,-8,(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(120)),
      Math.cos(degreesToRadians(135)),
      Math.cos(degreesToRadians(30))],
      8*Math.sqrt(3));

      // Y Bisect 
      addSegment('X_Pos_Z_Neg_Y_Bisect',[-4,0,(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(120)),
      Math.cos(degreesToRadians(90)),
      Math.cos(degreesToRadians(30))],
      8*Math.sqrt(3));


      // X Pos Z Neg 

      // Base
      testSegment([4,8,-(8*Math.sqrt(3))/2],[4,-8,-(8*Math.sqrt(3))/2]);

      // Y Pos
      addSegment('X_Pos_Z_Neg_Y_Pos',[4,8,-(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(300)),
      Math.cos(degreesToRadians(45)),
      Math.cos(degreesToRadians(210))],
      8*Math.sqrt(3));

      // Y Bisect
      addSegment('X_Pos_Z_Neg_Y_Bisect',[4,0,-(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(300)),
      Math.cos(degreesToRadians(90)),
      Math.cos(degreesToRadians(210))],
      8*Math.sqrt(3));

      // Y Neg
      addSegment('X_Pos_Z_Neg_Y_Neg',[4,-8,-(8*Math.sqrt(3))/2],
      [Math.cos(degreesToRadians(300)),
      Math.cos(degreesToRadians(135)),
      Math.cos(degreesToRadians(210))],
      8*Math.sqrt(3));
      

      scene.add(unit);

      const axesHelper = new THREE.AxesHelper( 50 );
      scene.add( axesHelper );

      scene.background = new THREE.Color(0x111111);

      const light0 = new THREE.DirectionalLight(0xfffffff, 1);
      light0.position.set(100, 100, 100)//.normalize();
      scene.add(light0);

      const light2 = new THREE.DirectionalLight(0xfffffff, 1);
      light2.position.set(-100, -100, -100)//.normalize();
      scene.add(light2);

      const light3 = new THREE.DirectionalLight(0xfffffff, 1);
      light3.position.set(100, -100, 100)//.normalize();
      scene.add(light3);

      const light4 = new THREE.DirectionalLight(0xfffffff, 1);
      light4.position.set(-100, 100, -100)//.normalize();
      scene.add(light4);

    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();
      //stats.update();
    }

    //unit.rotation.z -= .3;
    //unit.rotation.y -= .3;
    //unit.rotation.x += .3;

    function render() {

      const time = Date.now() * 0.002;

      //unit.rotation.x = time * 0.15;
      //unit.rotation.y = time * -0.01;
      //unit.rotation.z = time * .03;

      renderer.render(scene, camera);
    }

  </script>
</head>

<body>
</body>

</html>